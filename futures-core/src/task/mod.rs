//! Tasks used to drive a future computation
//!
//! It's intended over time a particular operation (such as servicing an HTTP
//! request) will involve many futures. This entire operation, however, can be
//! thought of as one unit, as the entire result is essentially just moving
//! through one large state machine.
//!
//! A "task" is the unit of abstraction for what is driving this state machine
//! and tree of futures forward. A task is used to poll futures and schedule
//! futures with, and has utilities for sharing data between tasks and handles
//! for notifying when a future is ready. Each task also has its own set of
//! task-local data generated by `task_local!`.
//!
//! Note that libraries typically should not manage tasks themselves, but rather
//! leave that to event loops and other "executors" (see the `executor` module),
//! or by using the `wait` method to create and execute a task directly on the
//! current thread.
//!
//! More information about the task model can be found [online at tokio.rs].
//!
//! [online at tokio.rs]: https://tokio.rs/docs/going-deeper-futures/futures-model/
//!
//! ## Functions
//!
//! There is an important bare function in this module: `current`. The
//! `current` function returns a handle to the currently running task, panicking
//! if one isn't present. This handle is then used to later wake the task that
//! it's ready to make progress through the `Task::wake` method.

use core::fmt;
use core::marker::PhantomData;

if_std! {
    use executor::Executor;
    type Exec<'a> = &'a mut Executor;
}

if_not_std! {
    type Exec<'a> = ();
}

mod atomic_waker;
pub use self::atomic_waker::AtomicWaker;

/// The context for the currently running task.
pub struct Context<'a> {
    waker: &'a Waker,
    map: &'a mut LocalMap,
    executor: Exec<'a>,
}

impl<'a> Context<'a> {
    /// TODO: dox
    pub fn waker(&self) -> Waker {
        self.waker.clone()
    }

    /// TODO: dox
    pub fn with_waker<'b>(&'b mut self, waker: &'b Waker) -> Context<'b> {
        Context { map: self.map, executor: self.executor, waker }
    }

    /// TODO: dox
    pub fn with_locals<'b>(&'b mut self, map: &'b mut LocalMap)
        -> Context<'b>
    {
        Context { map, waker: self.waker, executor: self.executor }
    }
}

if_std! {
    use std::boxed::Box;
    use Future;

    impl<'a> Context<'a> {
        /// TODO: dox
        pub fn new(map: &'a mut LocalMap, waker: &'a Waker, executor: &'a mut Executor) -> Context<'a> {
            Context { waker, map, executor }
        }

        /// TODO: dox
        pub fn executor(&mut self) -> &mut Executor {
            self.executor
        }

        /// TODO: dox
        pub fn spawn<F>(&mut self, f: F)
            where F: Future<Item = (), Error = ()> + 'static + Send
        {
            self.executor.spawn(Box::new(f)).unwrap()
        }
    }
}

if_not_std! {
    impl<'a> Context<'a> {
        /// TODO: dox
        pub fn new(map: &'a mut LocalMap, waker: &'a Waker) -> Context<'a> {
            Context { waker, map, executor: () }
        }
    }
}

impl<'a> fmt::Debug for Context<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Context")
         .finish()
    }
}

/// TODO: dox
pub struct LocalMap {
    #[allow(dead_code)]
    inner: data::LocalMap,
}

impl LocalMap {
    /// TODO: dox
    pub fn new() -> LocalMap {
        LocalMap { inner: data::local_map() }
    }
}

impl fmt::Debug for LocalMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("LocalMap")
         .finish()
    }
}

/// A trait which represents a sink of notifications that a future is ready to
/// make progress.
///
/// This trait is provided as an argument to the `Spawn::*_wake` family of
/// functions. It's transitively used as part of the `Task::wake` method to
/// internally deliver notifications of readiness of a future to move forward.
///
/// An instance of `Wake` has one primary method, `wake`, which is given a
/// contextual argument as to what's being notified. This contextual argument is
/// *also* provided to the `Spawn::*_wake` family of functions and can be used
/// to reuse an instance of `Wake` across many futures.
///
/// Instances of `Wake` must be safe to share across threads, and the methods
/// be invoked concurrently. They must also live for the `'static` lifetime,
/// not containing any stack references.
pub trait Wake: Send + Sync {
    /// Indicates that an associated future and/or task are ready to make
    /// progress.
    ///
    /// Typically this means that the receiver of the notification should
    /// arrange for the future to get poll'd in a prompt fashion.
    ///
    /// This method takes an `id` as an argument which was transitively passed
    /// in from the original call to `Spawn::*_wake`. This id can be used to
    /// disambiguate which precise future became ready for polling.
    ///
    /// # Panics
    ///
    /// Since `unpark` may be invoked from arbitrary contexts, it should
    /// endeavor not to panic and to do as little work as possible. However, it
    /// is not guaranteed not to panic, and callers should be wary. If a panic
    /// occurs, that panic may or may not be propagated to the end-user of the
    /// future that you'd otherwise wake up.
    fn wake(&self);
}

/// An unsafe trait for implementing custom forms of memory management behind a
/// `Task`.
///
/// The `futures` critically relies on "notification handles" to extract for
/// futures to contain and then later inform that they're ready to make
/// progress. These handles, however, must be cheap to create and cheap
/// to clone to ensure that this operation is efficient throughout the
/// execution of a program.
///
/// Typically this sort of memory management is done in the standard library
/// with the `Arc` type. An `Arc` is relatively cheap to allocate an is
/// quite cheap to clone and pass around. Plus, it's 100% safe!
///
/// When working outside the standard library, however, you don't always have
/// and `Arc` type available to you. This trait, `UnsafeWake`, is intended
/// to be the "unsafe version" of the `Wake` trait. This trait encodes the
/// memory management operations of a `Task`'s notification handle, allowing
/// custom implementations for the memory management of a notification handle.
///
/// Put another way, the core notification type in this library,
/// `Waker`, simply internally contains an instance of
/// `*mut UnsafeWake`. This "unsafe trait object" is then used exclusively
/// to operate with, dynamically dispatching calls to clone, drop, and wake.
/// Critically though as a raw pointer it doesn't require a particular form
/// of memory management, allowing external implementations.
///
/// A default implementation of the `UnsafeWake` trait is provided for the
/// `Arc` type in the standard library. If the `std` feature of this crate
/// is not available however, you'll be required to implement your own
/// instance of this trait to pass it into `Waker::new`.
///
/// # Unsafety
///
/// This trait is manually encoding the memory management of the underlying
/// handle, and as a result is quite unsafe to implement! Implementors of
/// this trait must guarantee:
///
/// * Calls to `clone_raw` produce uniquely owned handles. It should be safe
///   to drop the current handle and have the returned handle still be valid.
/// * Calls to `drop_raw` work with `self` as a raw pointer, deallocating
///   resources associated with it. This is a pretty unsafe operation as it's
///   invalidating the `self` pointer, so extreme care needs to be taken.
///
/// In general it's recommended to review the trait documentation as well as
/// the implementation for `Arc` in this crate. When in doubt ping the
/// `futures` authors to clarify an unsafety question here.
pub unsafe trait UnsafeWake: Wake {
    /// Creates a new `Waker` from this instance of `UnsafeWake`.
    ///
    /// This function will create a new uniquely owned handle that under the
    /// hood references the same notification instance. In other words calls
    /// to `wake` on the returned handle should be equivalent to calls to
    /// `wake` on this handle.
    ///
    /// # Unsafety
    ///
    /// This trait is unsafe to implement, as are all these methods. This
    /// method is also unsafe to call as it's asserting the `UnsafeWake`
    /// value is in a consistent state. In general it's recommended to
    /// review the trait documentation as well as the implementation for `Arc`
    /// in this crate. When in doubt ping the `futures` authors to clarify
    /// an unsafety question here.
    unsafe fn clone_raw(&self) -> Waker;

    /// Drops this instance of `UnsafeWake`, deallocating resources
    /// associated with it.
    ///
    /// This method is intended to have a signature such as:
    ///
    /// ```ignore
    /// fn drop_raw(self: *mut Self);
    /// ```
    ///
    /// Unfortunately in Rust today that signature is not object safe.
    /// Nevertheless it's recommended to implement this function *as if* that
    /// were its signature. As such it is not safe to call on an invalid
    /// pointer, nor is the validity of the pointer guaranteed after this
    /// function returns.
    ///
    /// # Unsafety
    ///
    /// This trait is unsafe to implement, as are all these methods. This
    /// method is also unsafe to call as it's asserting the `UnsafeWake`
    /// value is in a consistent state. In general it's recommended to
    /// review the trait documentation as well as the implementation for `Arc`
    /// in this crate. When in doubt ping the `futures` authors to clarify
    /// an unsafety question here.
    unsafe fn drop_raw(&self);
}

/// A `Waker` is the core value through which notifications are routed
/// in the `futures` crate.
///
/// All instances of `Task` will contain a `Waker` handle internally.
/// This handle itself contains a trait object pointing to an instance of the
/// `Wake` trait, allowing notifications to get routed through it.
///
/// The `Waker` type internally does not codify any particular memory
/// management strategy. Internally it contains an instance of `*mut
/// UnsafeWake`, and more details about that trait can be found on its own
/// documentation. Consequently, though, the one constructor of this type,
/// `Waker::new`, is `unsafe` to call. It is not recommended to call
/// this constructor directly.
///
/// If you're working with the standard library then it's recommended to
/// work with the `Arc` type. If you have a struct, `T`, which implements the
/// `Wake` trait, then you can construct this with
/// `Waker::from(t: Arc<T>)`. The coercion to `UnsafeWake` will
/// happen automatically and safely for you.
///
/// When working externally from the standard library it's recommended to
/// provide a similar safe constructor for your custom type as opposed to
/// recommending an invocation of `Waker::new` directly.
pub struct Waker {
    inner: *mut UnsafeWake,
}

unsafe impl Send for Waker {}
unsafe impl Sync for Waker {}

impl Waker {
    /// Constructs a new `Waker` directly.
    ///
    /// Note that most code will not need to call this. Implementers of the
    /// `UnsafeWake` trait will typically provide a wrapper that calls this
    /// but you otherwise shouldn't call it directly.
    ///
    /// If you're working with the standard library then it's recommended to
    /// use the `Waker::from` function instead which works with the safe
    /// `Arc` type and the safe `Wake` trait.
    #[inline]
    pub unsafe fn new(inner: *mut UnsafeWake) -> Waker {
        Waker { inner: inner }
    }

    /// dox
    pub fn wake(&self) {
        unsafe { (*self.inner).wake() }
    }
}

impl Clone for Waker {
    #[inline]
    fn clone(&self) -> Self {
        unsafe {
            (*self.inner).clone_raw()
        }
    }
}

impl fmt::Debug for Waker {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Waker")
         .finish()
    }
}

impl Drop for Waker {
    fn drop(&mut self) {
        unsafe {
            (*self.inner).drop_raw()
        }
    }
}

/// Marker for a `T` that is behind &'static.
struct StaticRef<T>(PhantomData<T>);

impl<T: Wake> Wake for StaticRef<T> {
    fn wake(&self) {
        let me = unsafe { &*(self as *const _ as *const T) };
        me.wake();
    }
}

unsafe impl<T: Wake + 'static> UnsafeWake for StaticRef<T> {
    unsafe fn clone_raw(&self) -> Waker {
        Waker::new(self as *const _ as *mut StaticRef<T>)
    }

    unsafe fn drop_raw(&self) {}
}

impl<T: Wake> From<&'static T> for Waker {
    fn from(src : &'static T) -> Waker {
        unsafe { Waker::new(src as *const _ as *mut StaticRef<T>) }
    }
}

if_std! {
    use std::mem;
    use std::ptr;
    use std::sync::Arc;

    mod data;

    pub use self::data::LocalKey;

    // Safe implementation of `UnsafeWake` for `Arc` in the standard library.
    //
    // Note that this is a very unsafe implementation! The crucial pieces is that
    // these two values are considered equivalent:
    //
    // * Arc<T>
    // * *const ArcWrapped<T>
    //
    // We don't actually know the layout of `ArcWrapped<T>` as it's an
    // implementation detail in the standard library. We can work, though, by
    // casting it through and back an `Arc<T>`.
    //
    // This also means that you won't actually find `UnsafeWake for Arc<T>`
    // because it's the wrong level of indirection. These methods are sort of
    // receiving Arc<T>, but not an owned version. It's... complicated. We may be
    // one of the first users of unsafe trait objects!

    struct ArcWrapped<T>(PhantomData<T>);

    impl<T: Wake + 'static> Wake for ArcWrapped<T> {
        fn wake(&self) {
            unsafe {
                let me: *const ArcWrapped<T> = self;
                T::wake(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))
            }
        }
    }

    unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {
        unsafe fn clone_raw(&self) -> Waker {
            let me: *const ArcWrapped<T> = self;
            let arc = (*(&me as *const *const ArcWrapped<T> as *const Arc<T>)).clone();
            Waker::from(arc)
        }

        unsafe fn drop_raw(&self) {
            let mut me: *const ArcWrapped<T> = self;
            let me = &mut me as *mut *const ArcWrapped<T> as *mut Arc<T>;
            ptr::drop_in_place(me);
        }
    }

    impl<T> From<Arc<T>> for Waker
        where T: Wake + 'static,
    {
        fn from(rc: Arc<T>) -> Waker {
            unsafe {
                let ptr = mem::transmute::<Arc<T>, *mut ArcWrapped<T>>(rc);
                Waker::new(ptr)
            }
        }
    }
}

#[cfg(not(feature = "std"))]
mod data {
    pub struct LocalMap;

    pub fn local_map() -> LocalMap {
        LocalMap
    }
}
