---
layout: post
title:  "Futures 0.3.0-alpha.3"
author: "Josef Brandl"
author_github: "MajorBreakfast"
date:   2018-01-01
categories: blog
---

This release introduces the `spawn!` and `spawn_with_handle!` macros for use in async functions, closures and blocks. Both macros let you spawn a task that polls the given future to completion. The task is spawned onto the current context's executor.

`spawn!` lets you spawn futures with `Output = ()`:

```rust
#![feature(async_await, await_macro, futures_api)]
#[macro_use] extern crate futures;

spawn!(future).unwrap();
```

`spawn_with_handle!` lets you spawn futures with any `Output: Send` type and also lets you await the produced output value:

```rust
let join_handle = spawn_with_handle!(future).unwrap();
let output = await!(join_handle);
```

`spawn!` is slightly cheaper than `spawn_with_handle!`.

Should spawning fail, a `SpawnError` error is returned which contains information about why it failed.

So what futures can be spawned? There are some requirements: The future needs to be `Send` and `'static` and the output needs to be `Send`. Here's why:
- The `'static` lifetime means that the future cannot contain any non-static (exterior) references. This is required so that the spawned task can be run independently to the task that spawns it.
- The `Send` bounds mean that the future and its output can be safely sent to other operating system threads. This is required so that multithreaded executors can run the spawned task on any operating thread they choose.

Note: You can execute non-`Send`, non-`'static` futures concurrently via the `join!` macro.

For use outside of async functions, there's also something new: The `ExecutorExt` trait. It provides the methods `spawn` and `spawn_with_handle`:

```rust
use futures::task::ExecutorExt;

// spawn()
executor.spawn(future).unwrap();

// spawn_with_handle()
let join_handle = executor.spawn_with_handle(future).unwrap();
```

Inside `poll`, you can use these methods by accessing the executor via `Context::executor`:

```rust
fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<T> {
    cx.executor().spawn(future);
}
```

## The plan: `spawn` with `dyn Future`

We plan to eventually replace `ExecutorExt::spawn` with `Executor::spawn`. This method will live directly in the `Executor` trait defined in libcore. It's signature will look like this:

```rust
fn spawn(
    &mut self,
    future: dyn Future<Output = ()> + Send + 'static,
) -> Result<(), SpawnError>
```

This method can't be implemented just yet due to compiler limitations:
- Arbitrary self types are currently not object-safe: `Future::poll` uses `PinMut` as arbitrary self type. This unfortunately makes it impossible to create trait objects for `Future`. Therefore, `Box<dyn Future>` and `&dyn Future` are *currently* not supported.
- Unsized rvalues are not yet available: Trait objects (`dyn Trait`) are `!Sized` because the size of a trait object depends on the size of the concrete type behind it and can therefore only be known at runtime. Currently we often use `Box<dyn Trait>` which stores the trait object on the heap to circumvent that. The unsized rvalues feature will make it possible to store `!Sized` types on the stack.

To circumvent these limitations, we currently have `FutureObj` and `Executor::spawn_obj`. These are, however, just a temporary solution until we can introduce the planned `spawn` method. The planned `spawn` method will make it possible to have one fewer heap allocation because the future is kept on the stack for as long as possible.
